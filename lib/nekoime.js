// Generated by CoffeeScript 1.7.1
(function() {
  var Datastore, backend, child_process, db, fs, home, nekoime, path, pinyin, request, result, source, _i, _j, _len, _len1, _ref, _ref1;

  fs = require('fs');

  path = require('path');

  child_process = require('child_process');

  pinyin = require('pinyin');

  request = require('request');

  Datastore = require('nedb');

  nekoime = {};

  nekoime.sources = (function() {
    var _i, _len, _ref, _results;
    _ref = fs.readdirSync('./lib/sources');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      result = require('./sources/' + source + '/manifest.json');
      result.id = source;
      if (fs.existsSync('./lib/sources/' + source + '/logo.png')) {
        result.logo = true;
      }
      if (fs.existsSync('./lib/sources/' + source + '/route.js')) {
        result.route = true;
      }
      _results.push(result);
    }
    return _results;
  })();

  nekoime.db = {};

  home = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;

  _ref = ['words', 'user'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    db = _ref[_i];
    nekoime.db[db] = new Datastore({
      filename: "" + home + "/.nekoime/" + db + ".db",
      autoload: true
    });
  }

  nekoime.db.words.ensureIndex({
    fieldName: 'word',
    unique: true
  });

  nekoime.backends = {};

  _ref1 = fs.readdirSync('./lib/backends');
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    backend = _ref1[_j];
    nekoime.backends[backend] = require('./backends/sunpinyin/backend');
    nekoime.backends[backend].id = backend;
    if (fs.existsSync('./lib/backends/' + backend + '/route.js')) {
      nekoime.backends[backend].route = true;
    }
  }

  nekoime.login_check = function(req, res, next) {
    return nekoime.db.user.findOne({}, function(err, doc) {
      if (err) {
        return res.send(500, err.toString());
      }
      if (doc) {
        return next();
      } else {
        return res.redirect('http://localhost:5285/login');
      }
    });
  };

  nekoime.update_profile = function(callback) {
    return nekoime.db.user.findOne({}, function(err, doc) {
      if (err) {
        return callback(err);
      }
      if (!doc) {
        return callback('not logged in');
      }
      return request({
        url: 'http://localhost:5285/profile',
        qs: {
          token: doc.token
        },
        json: true
      }, function(error, response, body) {
        if (error) {
          return callback(error);
        }
        return nekoime.db.user.update({}, {
          $set: {
            profile: body
          }
        }, function(err) {
          if (err) {
            return callback(err);
          }
          return callback();
        });
      });
    });
  };

  nekoime.backend = nekoime.backends.sunpinyin;

  nekoime.backend.load_words(function(dicts) {
    return nekoime.db.words.find({}, function(err, docs) {
      var dict, new_words, now, old_words, word, words, _k, _l, _len2, _len3;
      if (err) {
        throw err;
      }
      old_words = {};
      for (_k = 0, _len2 = docs.length; _k < _len2; _k++) {
        word = docs[_k];
        old_words[word.word] = true;
      }
      new_words = [];
      now = new Date();
      for (dict in dicts) {
        words = dicts[dict];
        console.log(dict, words.length);
        for (_l = 0, _len3 = words.length; _l < _len3; _l++) {
          word = words[_l];
          if (!(!old_words[word.word])) {
            continue;
          }
          new_words.push({
            word: word.word,
            frequencies: word.frequencies ? word.frequencies : void 0,
            pinyin: word.pinyin ? word.pinyin : void 0,
            updated_at: now,
            source: "local:sunpinyin:" + dict
          });
          old_words[word.word] = true;
        }
      }
      if (new_words.length) {
        return nekoime.db.words.insert(new_words, function(err, newDocs) {});
      }
    });
  });

  nekoime.save_words = function() {
    return nekoime.db.words.find({
      $not: {
        source: {
          $regex: /^local:/
        }
      }
    }, function(err, docs) {
      if (err) {
        return callback(err);
      }
      return nekoime.backend.save_words(docs, function(err) {
        if (err) {
          return nekoime.notify('保存词库失败', err.toString());
        } else {
          return nekoime.notify('NekoIME', '本地输入法词库已更新');
        }
      });
    });
  };

  nekoime.notify = function(summary, body) {
    if (body == null) {
      body = '';
    }
    return child_process.execFile('notify-send', ['--app-name=nekoime', "--icon=" + (path.join(process.cwd(), 'public/images/icon.png')), summary, body]);
  };

  nekoime.save_words();

  module.exports = nekoime;

}).call(this);

//# sourceMappingURL=nekoime.map
