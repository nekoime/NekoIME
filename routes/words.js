// Generated by CoffeeScript 1.7.1
(function() {
  var accentsMap, express, nekoime, pinyin, pinyinReplace, router, vowels;

  nekoime = require('../lib/nekoime');

  express = require("express");

  router = express.Router();

  accentsMap = {
    iao: 'ia*o',
    uai: 'ua*i',
    ai: 'a*i',
    ao: 'a*o',
    ei: 'e*i',
    ia: 'ia*',
    ie: 'ie*',
    io: 'io*',
    iu: 'iu*',
    Ai: 'A*i',
    Ao: 'A*o',
    Ei: 'E*i',
    ou: 'o*u',
    ua: 'ua*',
    ue: 'ue*',
    ui: 'ui*',
    uo: 'uo*',
    ve: 'üe*',
    Ou: 'O*u',
    a: 'a*',
    e: 'e*',
    i: 'i*',
    o: 'o*',
    u: 'u*',
    v: 'v*',
    A: 'A*',
    E: 'E*',
    O: 'O*'
  };

  vowels = ['a*', 'e*', 'i*', 'o*', 'u*', 'v*', 'A*', 'E*', 'O*'];

  pinyin = {
    1: ['ā', 'ē', 'ī', 'ō', 'ū', 'ǖ', 'Ā', 'Ē', 'Ī', 'Ō'],
    2: ['á', 'é', 'í', 'ó', 'ú', 'ǘ', 'Á', 'É', 'Í', 'Ó'],
    3: ['ǎ', 'ě', 'ǐ', 'ǒ', 'ǔ', 'ǚ', 'Ǎ', 'Ě', 'Ǐ', 'Ǒ'],
    4: ['à', 'è', 'ì', 'ò', 'ù', 'ǜ', 'À', 'È', 'Ì', 'Ò']
  };

  pinyinReplace = function(match) {
    var i, toneNumber, val, word;
    toneNumber = match.substr(-1, 1);
    word = match.substring(0, match.indexOf(toneNumber));
    for (val in accentsMap) {
      if (word.search(val) !== -1) {
        word = word.replace(new RegExp(val), accentsMap[val]);
        break;
      }
    }
    i = 0;
    while (i < 10) {
      word = word.replace(vowels[i], pinyin[toneNumber][i]);
      i++;
    }
    return word;
  };

  router.get("/", nekoime.login_check, function(req, res) {
    var order, query, sort, _i, _len, _ref;
    if (req.accepts('application/json', 'text/html') === 'application/json') {
      console.log(req.query);
      if (req.query.search.value.length) {
        query = nekoime.db.words.find({
          word: {
            $regex: new RegExp(req.query.search.value)
          }
        });
      } else {
        query = nekoime.db.words.find({});
      }
      _ref = req.query.order;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        order = _ref[_i];
        sort = {};
        sort[req.query.columns[order.column].name] = order.dir === 'desc' ? -1 : 1;
        console.log(sort);
        query.sort(sort);
      }
      query.skip(parseInt(req.query.start));
      query.limit(parseInt(req.query.length));
      return query.exec(function(err, docs) {
        if (err) {
          return res.send(500, err.toString());
        }
        return nekoime.db.words.count({}, function(err, count) {
          var column, p, word;
          if (err) {
            return res.send(500, err.toString());
          }
          return res.send({
            draw: req.query.draw,
            recordsTotal: count,
            recordsFiltered: count,
            data: (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {
                word = docs[_j];
                console.log(word.pinyin);
                word.updated_at = "" + (word.updated_at.getFullYear()) + "-" + (word.updated_at.getMonth() + 1) + "-" + (word.updated_at.getDate()) + " " + (word.updated_at.getHours()) + ":" + (word.updated_at.getMinutes()) + ":" + (word.updated_at.getSeconds());
                if (word.pinyin) {
                  word.pinyin = ((function() {
                    var _k, _len2, _ref1, _results1;
                    _ref1 = word.pinyin;
                    _results1 = [];
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                      p = _ref1[_k];
                      _results1.push(/^([a-zA-Z]+)([1-5])$/.test(p) ? pinyinReplace(p) : p);
                    }
                    return _results1;
                  })()).join(' ');
                }
                _results.push((function() {
                  var _k, _len2, _ref1, _results1;
                  _ref1 = req.query.columns;
                  _results1 = [];
                  for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                    column = _ref1[_k];
                    _results1.push(word[column.name]);
                  }
                  return _results1;
                })());
              }
              return _results;
            })()
          });
        });
      });
    } else {
      return res.render("words");
    }
  });

  module.exports = router;

}).call(this);

//# sourceMappingURL=words.map
