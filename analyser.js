// Generated by CoffeeScript 1.7.1
(function () {
    var OpenCC, article, cohesion, combination, combinations, count, file, fs, i, index, left_border, left_entropy, left_neibor, left_neibors, length, max_length, min_cohesion, min_entropy, min_frequencies, opencc, p, p_combined, right_border, right_entropy, right_neibor, right_neibors, sentence, sentences, sysdict, total_length, word, words, _, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2, _ref3,
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    fs = require('fs');

    OpenCC = require('opencc');

    opencc = new OpenCC('t2s.json');

    _ = require('underscore');

    _.str = require('underscore.string');

    _.mixin(_.str.exports());

    max_length = 6;

    min_cohesion = 300;

    min_entropy = 1;

    combinations = function (word, allow_whole) {
        var first_part, i, rest_part, result, s, _i, _j, _len, _ref;
        if (allow_whole == null) {
            allow_whole = false;
        }
        result = [];
        for (i = _i = 1, _ref = (allow_whole ? word.length : word.length - 1); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            first_part = word.slice(0, i);
            if (i === word.length) {
                result.push([word]);
            } else {
                rest_part = combinations(word.slice(i), true);
                for (_j = 0, _len = rest_part.length; _j < _len; _j++) {
                    s = rest_part[_j];
                    s.unshift(first_part);
                    result.push(s);
                }
            }
        }
        return result;
    };

    if (process.argv[0]) {
        console.error("load " + (process.argv.length - 2) + " files");
        words = {};
        sentences = [];
        _ref = process.argv.slice(2);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            article = fs.readFileSync(file, {
                encoding: 'utf8'
            });
            article = opencc.convertSync(article);
            _ref1 = article.split(/[^\u4E00-\u9FA5]+/);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                sentence = _ref1[_j];
                if (!(sentence.length > 0)) {
                    continue;
                }
                sentences.push(sentence);
                for (length = _k = 1, _ref2 = Math.min(max_length, sentence.length); 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; length = 1 <= _ref2 ? ++_k : --_k) {
                    for (i = _l = 0, _ref3 = sentence.length - length; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
                        word = sentence.substr(i, length);
                        if (words[word]) {
                            words[word]++;
                        } else {
                            words[word] = 1;
                        }
                    }
                }
            }
        }
        console.error("load " + sentences.length + " sentences");
        for (word in words) {
            if (words.length >= 2 && _.count(words, words[0]) === words.length) {
                words[word] = _.reduce(sentences, function (memo, sentence) {
                    return memo + _.count(sentence, word);
                }, 0);
            }
        }
        console.error("load " + (_.size(words)) + " words");
        total_length = _.reduce(sentences, function (memo, sentence) {
            return memo + sentence.length;
        }, 0);
        min_frequencies = Math.log(total_length);
        sysdict = _.lines(fs.readFileSync('sysdict.txt', {
            encoding: 'utf8'
        }));
        console.error("load " + sysdict.length + " system words");
        for (word in words) {
            count = words[word];
            if (!(count >= min_frequencies && word.length >= 2)) {
                continue;
            }
            if (__indexOf.call(sysdict, word) >= 0) {
                continue;
            }
            p = count / total_length;
            p_combined = Math.max.apply(this, (function () {
                var _len2, _m, _ref4, _results;
                _ref4 = combinations(word);
                _results = [];
                for (_m = 0, _len2 = _ref4.length; _m < _len2; _m++) {
                    combination = _ref4[_m];
                    _results.push(_.reduce(combination, function (memo, part) {
                        return memo * words[part] / total_length;
                    }, 1));
                }
                return _results;
            })());
            cohesion = p / p_combined;
            if (cohesion < min_cohesion) {
                continue;
            }
            left_neibors = {};
            right_neibors = {};
            left_border = 0;
            right_border = 0;
            for (_m = 0, _len2 = sentences.length; _m < _len2; _m++) {
                sentence = sentences[_m];
                index = 0;
                while ((index = sentence.indexOf(word, index)) !== -1) {
                    left_neibor = sentence[index - 1];
                    index += word.length;
                    right_neibor = sentence[index];
                    if (left_neibor) {
                        if (left_neibors[left_neibor]) {
                            left_neibors[left_neibor]++;
                        } else {
                            left_neibors[left_neibor] = 1;
                        }
                    } else {
                        left_border++;
                    }
                    if (right_neibor) {
                        if (right_neibors[right_neibor]) {
                            right_neibors[right_neibor]++;
                        } else {
                            right_neibors[right_neibor] = 1;
                        }
                    } else {
                        right_border++;
                    }
                }
            }
            left_entropy = _.reduce(left_neibors, function (memo, c) {
                return memo + -Math.log(c / count) * c / (count - left_border);
            }, 0);
            if (left_entropy < min_entropy) {
                continue;
            }
            right_entropy = _.reduce(right_neibors, function (memo, c) {
                return memo + -Math.log(c / count) * c / (count - right_border);
            }, 0);
            if (right_entropy < min_entropy) {
                continue;
            }
            console.log(word, count, parseInt(cohesion), Math.min(left_entropy, right_entropy));
        }
        console.error('done');
    } else {
        console.log('Usage: node analyser.js files');
    }

}).call(this);

//# sourceMappingURL=analyser.map
